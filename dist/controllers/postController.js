"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deletePost = exports.updatePost = exports.getPostBySlug = exports.getPosts = exports.createPost = void 0;
const express_validator_1 = require("express-validator");
const Post_1 = __importDefault(require("../models/Post"));
const createPost = async (req, res, next) => {
    try {
        const errors = (0, express_validator_1.validationResult)(req);
        if (!errors.isEmpty()) {
            res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array(),
            });
            return;
        }
        const { title, content, tags, status } = req.body;
        const authorId = req.user._id;
        // Slug will be auto-generated by the model's pre-save hook
        const post = await Post_1.default.create({
            title,
            content,
            author: authorId,
            tags: tags || [],
            status: status || 'draft',
        });
        await post.populate('author', 'name email');
        res.status(201).json({
            success: true,
            message: 'Post created successfully',
            data: { post },
        });
    }
    catch (error) {
        next(error);
    }
};
exports.createPost = createPost;
const getPosts = async (req, res, next) => {
    try {
        const { page = '1', limit = '10', search, tag, author, status, } = req.query;
        const pageNum = parseInt(page, 10);
        const limitNum = parseInt(limit, 10);
        const skip = (pageNum - 1) * limitNum;
        // Build query
        const query = { deletedAt: null };
        // Public users can only see published posts
        // Authenticated users can filter by status but only see their own drafts
        if (req.user) {
            // Authenticated user
            if (status === 'draft') {
                // Only show drafts authored by the current user
                query.status = 'draft';
                query.author = req.user._id;
            }
            else if (status === 'published') {
                query.status = 'published';
            }
            else {
                // No status filter: show published posts + user's own drafts
                query.$or = [
                    { status: 'published' },
                    { status: 'draft', author: req.user._id },
                ];
            }
        }
        else {
            // Public user: only published posts
            query.status = 'published';
        }
        // Search filter (title or content)
        if (search) {
            query.$and = query.$and || [];
            query.$and.push({
                $or: [
                    { title: { $regex: search, $options: 'i' } },
                    { content: { $regex: search, $options: 'i' } },
                ],
            });
        }
        // Tag filter
        if (tag) {
            query.tags = { $in: [tag] };
        }
        // Author filter
        if (author) {
            query.author = author;
        }
        // Execute query
        const posts = await Post_1.default.find(query)
            .populate('author', 'name email')
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limitNum);
        const total = await Post_1.default.countDocuments(query);
        res.status(200).json({
            success: true,
            message: 'Posts retrieved successfully',
            data: {
                posts,
                pagination: {
                    page: pageNum,
                    limit: limitNum,
                    total,
                    pages: Math.ceil(total / limitNum),
                },
            },
        });
    }
    catch (error) {
        next(error);
    }
};
exports.getPosts = getPosts;
const getPostBySlug = async (req, res, next) => {
    try {
        const { slug } = req.params;
        const query = { slug, deletedAt: null };
        // Public users can only see published posts
        if (req.user) {
            // Authenticated users can see published posts or their own drafts
            query.$or = [
                //{ status: 'published' },
                { status: ['draft', 'pusblished'], author: req.user._id },
            ];
        }
        else {
            query.status = 'published';
        }
        const post = await Post_1.default.findOne(query).populate('author', 'name email');
        if (!post) {
            res.status(404).json({
                success: false,
                message: 'Post not found',
            });
            return;
        }
        res.status(200).json({
            success: true,
            message: 'Post retrieved successfully',
            data: { post },
        });
    }
    catch (error) {
        next(error);
    }
};
exports.getPostBySlug = getPostBySlug;
const updatePost = async (req, res, next) => {
    try {
        const errors = (0, express_validator_1.validationResult)(req);
        if (!errors.isEmpty()) {
            res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array(),
            });
            return;
        }
        const { id } = req.params;
        const { title, content, tags, status } = req.body;
        const post = await Post_1.default.findById(id);
        if (!post || post.deletedAt) {
            res.status(404).json({
                success: false,
                message: 'Post not found',
            });
            return;
        }
        // Update fields
        // Slug will be auto-regenerated by the model's pre-save hook if title changes
        if (title !== undefined)
            post.title = title;
        if (content !== undefined)
            post.content = content;
        if (tags !== undefined)
            post.tags = tags;
        if (status !== undefined)
            post.status = status;
        // updatedAt will be set by the model's pre-save hook
        await post.save();
        await post.populate('author', 'name email');
        res.status(200).json({
            success: true,
            message: 'Post updated successfully',
            data: { post },
        });
    }
    catch (error) {
        next(error);
    }
};
exports.updatePost = updatePost;
const deletePost = async (req, res, next) => {
    try {
        const { id } = req.params;
        const post = await Post_1.default.findById(id);
        if (!post || post.deletedAt) {
            res.status(404).json({
                success: false,
                message: 'Post not found',
            });
            return;
        }
        // Soft delete
        post.deletedAt = new Date();
        await post.save();
        res.status(200).json({
            success: true,
            message: 'Post deleted successfully',
        });
    }
    catch (error) {
        next(error);
    }
};
exports.deletePost = deletePost;
//# sourceMappingURL=postController.js.map