import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';
import Post from '../models/Post';
import logger from '../utils/logger';

export const createPost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array(),
      });
      return;
    }

    const { title, content, tags, status } = req.body;
    const authorId = req.user!._id;

    // Slug will be auto-generated by the model's pre-save hook
    const post = await Post.create({
      title,
      content,
      author: authorId,
      tags: tags || [],
      status: status || 'draft',
    });

    await post.populate('author', 'name email');

    logger.info('Post created successfully', {
      postId: post._id.toString(),
      slug: post.slug,
      authorId: authorId.toString(),
      status: post.status,
    });

    res.status(201).json({
      success: true,
      message: 'Post created successfully',
      data: { post },
    });
  } catch (error: any) {
    next(error);
  }
};

export const getPosts = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const {
      page = '1',
      limit = '10',
      search,
      tag,
      author,
      status,
    } = req.query;

    const pageNum = parseInt(page as string, 10);
    const limitNum = parseInt(limit as string, 10);
    const skip = (pageNum - 1) * limitNum;

    // Build query
    const query: any = { deletedAt: null };

    // Public users can only see published posts
    // Authenticated users can filter by status but only see their own drafts
    if (req.user) {
      // Authenticated user
      if (status === 'draft') {
        // Only show drafts authored by the current user
        query.status = 'draft';
        query.author = req.user._id;
      } else if (status === 'published') {
        query.status = 'published';
      } else {
        // No status filter: show published posts + user's own drafts
        query.$or = [
          { status: 'published' },
          { status: 'draft', author: req.user._id },
        ];
      }
    } else {
      // Public user: only published posts
      query.status = 'published';
    }

    // Search filter (title or content)
    if (search) {
      query.$and = query.$and || [];
      query.$and.push({
        $or: [
          { title: { $regex: search, $options: 'i' } },
          { content: { $regex: search, $options: 'i' } },
        ],
      });
    }

    // Tag filter
    if (tag) {
      query.tags = { $in: [tag] };
    }

    // Author filter
    if (author) {
      query.author = author;
    }

    // Execute query
    const posts = await Post.find(query)
      .populate('author', 'name email')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limitNum);

    const total = await Post.countDocuments(query);

    logger.debug('Posts retrieved', {
      count: posts.length,
      total,
      page: pageNum,
      limit: limitNum,
      filters: { search, tag, author, status },
    });

    res.status(200).json({
      success: true,
      message: 'Posts retrieved successfully',
      data: {
        posts,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          pages: Math.ceil(total / limitNum),
        },
      },
    });
  } catch (error: any) {
    next(error);
  }
};

export const getPostBySlug = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { slug } = req.params;

    console.log("slug", slug)

    const query: any = { slug, deletedAt: null };

    // Public users can only see published posts
    if (req.user) {
      // Authenticated users can see published posts or their own drafts
      query.$or = [
        { status: 'published' },
        { status: 'draft', author: req.user._id },
      ];
    } else {
      query.status = 'published';
    }

    const post = await Post.findOne(query).populate('author', 'name email');

    if (!post) {
      res.status(404).json({
        success: false,
        message: 'Post not found',
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: 'Post retrieved successfully',
      data: { post },
    });
  } catch (error: any) {
    next(error);
  }
};

export const updatePost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array(),
      });
      return;
    }

    const { id } = req.params;
    const { title, content, tags, status } = req.body;

    const post = await Post.findById(id);

    if (!post || post.deletedAt) {
      res.status(404).json({
        success: false,
        message: 'Post not found',
      });
      return;
    }

    // Update fields
    // Slug will be auto-regenerated by the model's pre-save hook if title changes
    if (title !== undefined) post.title = title;
    if (content !== undefined) post.content = content;
    if (tags !== undefined) post.tags = tags;
    if (status !== undefined) post.status = status;
    // updatedAt will be set by the model's pre-save hook

    await post.save();
    await post.populate('author', 'name email');

    logger.info('Post updated successfully', {
      postId: post._id.toString(),
      slug: post.slug,
      authorId: post.author._id.toString(),
    });

    res.status(200).json({
      success: true,
      message: 'Post updated successfully',
      data: { post },
    });
  } catch (error: any) {
    next(error);
  }
};

export const deletePost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;

    const post = await Post.findById(id);

    if (!post || post.deletedAt) {
      res.status(404).json({
        success: false,
        message: 'Post not found',
      });
      return;
    }

    // Soft delete
    post.deletedAt = new Date();
    await post.save();

    logger.info('Post soft deleted successfully', {
      postId: post._id.toString(),
      slug: post.slug,
      authorId: post.author._id.toString(),
    });

    res.status(200).json({
      success: true,
      message: 'Post deleted successfully',
    });
  } catch (error: any) {
    next(error);
  }
};
